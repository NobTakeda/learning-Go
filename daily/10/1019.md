## 2025年10月19日（日）

### A Tour of Go
### 5-1: Methods
+ Goではclassは無いが、structにメソッドを定義できる
```
type Vertex struct {
	X, Y float64
}

// AbsはVertexを返すメソッド。
// レシーバvは値（Vertex）で受け取り、返り値は float64となる。
// 呼び方はv.Abs()
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// 引数vの長さを返す関数Abs()として書くとこうなる。
// 呼び方はAbs(v)
func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```
+ 関数とメソッドは似ているが、メソッドはインターフェースの実装として使用できる。
+ structだけでなく、typeにもメソッドは宣言できる
+ レシーバを伴うメソッドは、同じパッケージ内でのみ宣言できる

### 5-4: Pointer receivers
+ ポインタレシーバでメソッドを宣言することもできる。
```
// vはこのメソッドに渡してもvのコピーとなるので、関数の外では値が変わらない
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// ポインタレシーバにした場合、v.Scale()で*Vertex（アドレス）を渡すので、関数の外でも値が書き変わる
// v.Scale(10)は実質(&v).Scale(10)と同じ意味
func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}
```

+ また、メソッドと関数で引数の渡し方に違いが出る
```
func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}
// こちらは、使用するときはこうなる
	v := Vertex{3, 4}
	v.Scale(2)

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}
// こちらは関数なので
	ScaleFunc(v, 10) → エラーとなる
	ScaleFunc(&v, 10) → OK
```
+ 値渡しと参照渡しで混乱が生じるので、同じ型では値かポインタかを統一するのが実務的な定石とのこと
