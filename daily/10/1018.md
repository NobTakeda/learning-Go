## 2025年10月18日（土）

### A Tour of Go
### 4-11: Slice length and capacity
+ スライスは長さ( length )と容量( capacity )を持つ
+ サンプルコードで疑問に思ったのだが、PHPと違いGoではスライスを代入する場合、ヘッダのコピーのみとなり配列は裏で保持されている
```
a := []int{2, 3, 5, 7, 11, 13} // 裏配列(長さ6)が1つある
s := a[0:6]  // len=6 cap=6, 先頭= a[0]

s = s[:0]    // lenだけ0に。裏配列は同じ（cap=6のまま）
s = s[:4]    // len=4に戻す。まだ同じ裏配列
s = s[2:]    // 先頭を2つ進める。裏配列は同じだが、"見える先頭"が a[2] になる
```
+ 上記のコードでは裏配列は変わっておらず、appendで要素数に変化があった時に、もう一つの配列が生成されることになる。
```
a := []int{1, 2, 3, 4} // cap=4
s := a[1:3]            // len=2, cap=3 (先頭を1進めたので 4-1=3)

// ここのappendではまだcap=3の範囲内（len=3に1要素追加で裏配列と同じ要素数となるため）
s = append(s, 8) 
fmt.Println(a)         // [1 2 3 8] ← a[3] が上書きされている（同じ裏配列）

// ここのappendでcapを超過し、新しい裏配列に移ることとなる
s = append(s, 9)
s[0] = 100
fmt.Println(a)         // [1 2 3 8]  ← もう影響しない（裏が別になった）
fmt.Println(s)         // [100 3 8 9]
```

### 4-13: Creating a slice with make
+ スライスは、組み込みのmake関数を使用して作成することができる
```
// 第一引数に型、第二引数にlen、第三引数でcapを指定
b := make([]int, 0, 5)  // この場合、int型のcap=5、現在中身はなしとなる。
```

### 4-16: Range
+ rangeを使うと、PHPのforeachと似たような回し方ができる。
```
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    // iはindex、rangeを使うとpowを要素数ぶん回す、という意味になる。
	for i, v := range pow {
        // for文内のvはコピーとなるので、中でvをいじっても元の配列は変わらない。
        // 変えたい場合は、pow[i] = x のような形で、indexを指定する必要があることに注意
		fmt.Printf("2**%d = %d\n", i, v)
	}
}
```

### 4-19: Maps
+ `var m map[string]Vertex`で, keyがstring, valueがVertexのマップmを宣言することができる。
+ 宣言した段階ではnilのため、make関数で使用できるようセットする必要がある。
```
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])

m へ要素(elem)の挿入や更新:
m[key] = elem

要素の取得:
elem = m[key]

要素の削除:
delete(m, key)

キーに対する要素が存在するかどうかは、2つの目の値で確認する:
// okにbooleanで返る
elem, ok = m[key]
```

### 4-24: Function values
+ Goでは、関数を引数として渡すことができる
+ 
```
import "fmt"

func counter() func() int {
    // この変数を内側の関数が持ち歩く
    n := 0     
    return func() int {
        // 中身を書き換える
        n++
        return n
    }
}

func main() {
    c := counter()        // c は「n を覚えている関数」

    fmt.Println(c()) // 1  （n: 0→1）
    fmt.Println(c()) // 2  （n: 1→2）
    fmt.Println(c()) // 3  （n: 2→3）

    d := counter()        // もう一つ作ると別のカウンターになる（n=0から）
    fmt.Println(d()) // 1
}
```
