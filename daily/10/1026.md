
## 2025年10月25日（土）

### A Tour of Go
### 5-16~: Type assertions
+ 型アサーションについて
```go
// iは空のインターフェースであり、どんな型でも入る。
// この場合(value="hello", type=string)
var i interface{} = "hello"
```
#### 使い所
1. JSONの汎用デコード結果から安全に取り出す  
APIのレスポンスやファイルからのパースなど
```go
var v any
_ = json.Unmarshal([]byte(`{"name":"Test","age":88}`), &v)

// まずはオブジェクトかを判定
m, ok := v.(map[string]any)
if !ok { /* エラー処理 */ }

name, _ := m["name"].(string) // stringか判定
age,  _ := m["age"].(float64)
fmt.Println(name, int(age))
```
2. io.Writer / io.Reader
```go
func dump(w io.Writer) {
	// bytes.Bufferなら中身を直接見る
	if b, ok := w.(*bytes.Buffer); ok {
		fmt.Println("raw bytes:", b.Bytes())
		return
	}
	// それ以外の処理
	fmt.Fprintln(w, "hello")
}
```

### 5-16: Type switches
+ インターフェースを使用し、switch文で型を判定することができる
```go
// iにはどんな値でも入る
func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
```

### 5-17: Stringers
+ fmtにはStringerインターフェースが用意されている。
+ そのため、自分の型に`String() string`メソッドを定義することで、  
`fmt.Println`や`fmt.Printf("%v")`を使った時にメソッドの返り値を使用することができる。
```go
// Goは暗黙のインターフェース実装を行うので、こう書けばTは自動的にfmt.Stringerを満たす。
func (t T) String() string { ... }
```
+ `fmt.Printf("%v", x)`, `fmt.Println(x)`などは、値xが`String() string`を持っていればその戻り値を表示に使う。  
持っていない場合は、デフォルトの構造体での表示となる。