## 2025年10月13日（月）

### A Tour of Go
### 3-14: Defer

+ 関数内でdeferを使用すると、その処理を関数の終わりまで遅延させることができる
+ finallyのようなものだが、使用している関数はdeferの行の時点での評価となる
+ for文内でdeferを使用した時など、deferを同関数で複数使っている場合、  
最後にまとめて表示される。表示順は最後に入れたものから最初まで。

### 4-1: Pointers
+ 変数を宣言する時、&を使用するとそのオペランドへのポインタを使用する文となる。
```
	i, j := 42, 2701

    // ポインタpにiの値を代入する
	p := &i 

    // *を使用することで、ポインタpの値を読み出す
    fmt.Println(*p)

    // ポインタpに21を代入
    *p = 21
```

### 4-2: Struct
+ structを使用することで、フィールドの集まりを宣言することができる
```
type Vertex struct {
	X int
	Y int
}

v := Vertex{X: 3, Y: 4}     // フィールド名を指定して初期化
fmt.Println(v.X, v.Y)       // 3, 4が出力される

v2 := Vertex{}              // ゼロ値が入る（X=0,Y=0）
v2.X = 10

p := &v                     // ポインタ経由でもフィールドにアクセス可（本来なら(*p).Xと書く）
p.Y = 99                    // v.Y も 99 に変わる
```

### 4-6: Arrays
+ 配列は`var a [10]int`のような形で宣言する。  
int型の要素数が10個のaという配列を宣言している。要素数は10から変えられない。

### 4-7: Slices
+ 要素数を書かないことにより、スライスも宣言できる。  
`var s []int` → ゼロ値のスライス。 len=0, cap=0, s==nil は true  
`s = append(s, 1)`でそのまま値を加えることができる
```
	primes := [6]int{2, 3, 5, 7, 11, 13}
    // コロンで区切られた二つのインデックス、lowとhighを指定して切り出すことができる。
    // 切り出される要素のindexはlow以上、high未満
	var s []int = primes[1:4]
```