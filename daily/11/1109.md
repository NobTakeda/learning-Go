## 2025年11月2日（日）

### A Tour of Go
### 6-4: Range and Close
+ 送り手はこれ以上の送信する値がないことを示すため、チャネルをcloseすることができる
+ closeするのは送り手のみ。受け手がcloseしたチャネルへ送信してしまうとpanicになるので注意
+ チャネルは通常closeする必要はなく勝手に閉じるが、下記のコード例のようにrangeループを終了したい時などに使う。
```go
package main

import (
	"fmt"
)

// フィボナッチ数列をn個生成し、チャネルcに順番に送信する。
func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		c <- x
		x, y = y, x+y
	}
    // チャネルcに送り終わったらclose
	close(c)
}

func main() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)

    // c から値を受け取り続け、送信されるものが無くなったらループ終了（cがclose済み＋空になった時）
	for i := range c {
		fmt.Println(i)
	}
}
```

### 6-5: Select
+ ゴルーチンの中でselectを使用することで、チャネルの送受信の“準備完了”に応じて分岐することができる
+ 同時に複数ケースが可能なら、ランダムに1つ選ぶ。優先させたい場合はロジックで制御する
+ defaultケースを入れると、どのチャネルも今は無理なときに即座にdefaultを実行し、ブロックしなくなる
```go
func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c <- x:        // 送れるなら送る
            x, y = y, x+y   // 次の値へ
        case <-quit:        // quitから受信できるなら
            fmt.Println("quit")
            return
        }
    }
}
```
+ タイムアウトは`time.After()`でよく書かれるとのこと
```go
select {
case v := <-ch:
    use(v)
case <-time.After(500 * time.Millisecond):
    log.Println("timeout")
}
```